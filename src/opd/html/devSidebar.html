<button id="benchmark-button" class="create full-width row">
  <span class="material-symbols-outlined">
    speed
  </span>
  Run Benchmark
  <span class="material-symbols-outlined">
    speed
  </span>
</button>
<link href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script>
<script>
  $(function() {
    console.log('test');
    $('#benchmark-button').click(requestBenchmark);
  });

  function throwError(error) {
    throw new Error(error.message);
  }
  
  async function requestBenchmark() {
    let iterationCount = askForIterationCount();
    console.log('iterationCount', iterationCount);
    let result = confirm('Are you sure you want to run the benchmark ' + iterationCount + ' times?');
    if (result == false) {
      console.log('Benchmark Stopped');
      return;
    }
    while(iterationCount > 0) {
      let results = await runBenchmarkTests();
      console.debug('results', results);
      iterationCount--;
    }
    toastr.success('Benchmark complete');
  }

  function askForIterationCount() {
    var iterationCount = prompt('How many iterations would you like to run?');
    if (typeof iterationCount !== 'number') {
      iterationCount = parseInt(iterationCount);
      if (iterationCount == NaN) {
        alert('Invalid input. Please enter a number.');
        return askForIterationCount();
      }
    }
    if (iterationCount <= 0) {
      alert('Invalid input. Please enter a positive number.');
      return askForIterationCount();
    }
    return iterationCount;
  }

  async function runBenchmarkTests() {
    let results = {};
    benchmarkNextFunction = true;
    let start = performance.now();
    await jumpToProject();
    let end = performance.now();
    results['jumpToProjects'] = end - start;
    console.debug('jumpToProjects', results['jumpToProjects']);
    toastr.success('jumpToProjects', results['jumpToProjects']);

    try {
      startLoading('Selecting Empty Project');
      await selectEmptyProject();
      results['getInitiative from empty project'] = await new Promise(resolve => setTimeout(async function() {
        stopLoading();
        benchmarkNextFunction = true;
        start = performance.now();
        await refreshSidebar();
        end = performance.now();
        resolve(end - start);
      }, 5000));
      if (globalInitiative.title == "A fatal error has occured") {
        throw new Error('A fatal error has occured');
      }
      toastr.success('getInitiative from empty project', results['getInitiative from empty project']);
      console.debug('getInitiative from empty project', results['getInitiative from empty project']);
    } catch (error) {
      stopLoading();
      console.error('Error selecting empty project: ' + error.message);
      alert('Error selecting empty project: ' + error.message);
      return;
    }

    try {
      startLoading('Filling in Blank Information');
      await selectNoDocsProject();
      results['getInitiative from project with no docs'] = await new Promise(resolve => setTimeout(async function() {
        stopLoading();
        benchmarkNextFunction = true;
        start = performance.now();
        await refreshSidebar();
        end = performance.now();
        resolve(end - start);
      }, 5000));
      if (globalInitiative.title == "A fatal error has occured") {
        throw new Error('A fatal error has occured');
      }
      toastr.success('getInitiative from project with no docs', results['getInitiative from project with no docs']);
      console.debug('getInitiative from project with no docs', results['getInitiative from project with no docs']);
    } catch (error) {
      stopLoading();
      console.error('Error selecting no docs project: ' + error.message);
      alert('Error selecting no docs project: ' + error.message);
      return;
    }
    
    benchmarkNextFunction = true;
    start = performance.now();
    await generateJob();
    end = performance.now();
    results['generateProject from existing client'] = end - start;
    if (globalInitiative.title == "A fatal error has occured") {
      error = new Error('A fatal error has occured');
      console.error('Error generating job from existing client: ' + error.message);
      alert('Error generating job from existing client: ' + error.message);
      return;
    }
    toastr.success('generateProject from existing client', results['generateProject from existing client']);
    console.debug('generateProject from existing client', results['generateProject from existing client']);

    try {
      startLoading('Deleting Project and Client Files');
      await deleteProjectFiles();
      await deleteClientFiles();
      results['generateProject from new client'] = await new Promise(resolve => setTimeout(async function() {
        stopLoading();
        await refreshSidebar();
        benchmarkNextFunction = true;
        start = performance.now();
        await generateJob();
        end = performance.now();
        resolve(end - start);
      }, 5000));
      if (globalInitiative.title == "A fatal error has occured") {
        throw new Error('A fatal error has occured');
      }
      console.debug('generateProject from new client', results['generateProject from new client']);
      toastr.success('generateProject from new client', results['generateProject from new client']);
    } catch (error) {
      stopLoading();
      console.error('Error generating job from new client: ' + error.message);
      alert('Error generating job from new client: ' + error.message);
      return;
    }

    try {
      startLoading('Deleting Project Files');
      await deleteProjectFiles();
      stopLoading();
      benchmarkNextFunction = true;
      start = performance.now();
      await jumpToProposal();
      end = performance.now();
      results['jumpToProposals'] = end - start;
      console.debug('jumpToProposals', results['jumpToProposals']);
      toastr.success('jumpToProposals', results['jumpToProposals']);
    } catch (error) {
      stopLoading();
      console.error('Error jumping to proposals: ' + error.message);
      alert('Error jumping to proposals: ' + error.message);
      return;
    }

    try {
      startLoading('Selecting Empty Proposal');
      await selectEmptyProposal();
      results['getInitiative from empty proposal'] = await new Promise(resolve => setTimeout(async function() {
        stopLoading();
        benchmarkNextFunction = true;
        start = performance.now();
        await refreshSidebar();
        end = performance.now();
        resolve(end - start);
      }, 5000));
      if (globalInitiative.title == "A fatal error has occured") {
        throw new Error('A fatal error has occured');
      }
      toastr.success('getInitiative from empty proposal', results['getInitiative from empty proposal']);
      console.debug('getInitiative from empty proposal', results['getInitiative from empty proposal']);
    } catch (error) {
      stopLoading();
      console.error('Error selecting new proposal: ' + error.message);
      alert('Error selecting new proposal: ' + error.message);
      return;
    }

    try {
      startLoading('Filling in Blank Information');
      await selectNoDocsProposal();
      results['getInitiative from proposal with no docs'] = await new Promise(resolve => setTimeout(async function() {
        stopLoading();
        benchmarkNextFunction = true;
        start = performance.now();
        await refreshSidebar();
        end = performance.now();
        resolve(end - start);
      }, 5000));
      if (globalInitiative.title == "A fatal error has occured") {
        throw new Error('A fatal error has occured');
      }
      toastr.success('getInitiative from proposal with no docs', results['getInitiative from proposal with no docs']);
      console.debug('getInitiative from proposal with no docs', results['getInitiative from proposal with no docs']);
    } catch (error) {
      stopLoading();
      console.error('Error selecting no docs proposal: ' + error.message);
      alert('Error selecting no docs proposal: ' + error.message);
      return;
    }

    benchmarkNextFunction = true;
    start = performance.now();
    await generateProposal();
    end = performance.now();
    if (globalInitiative.title == "A fatal error has occured") {
      error = new Error('A fatal error has occured');
      console.error('Error generating proposal from existing client: ' + error.message);
      alert('Error generating proposal from existing client: ' + error.message);
      return;
    }
    results['generateProposal from existing client'] = end - start;
    toastr.success('generateProposal from existing client', results['generateProposal from existing client']);
    console.debug('generateProposal from existing client', results['generateProposal from existing client']);

    try {
      startLoading('Deleting Proposal and Client Files');
      await deleteProposalFiles();
      await deleteClientFiles();
      results['generateProposal from new client'] = await new Promise(resolve => setTimeout(async function() {
        stopLoading();
        await refreshSidebar();
        benchmarkNextFunction = true;
        start = performance.now();
        await generateProposal();
        end = performance.now();
        resolve(end - start);
      }, 5000));
      if (globalInitiative.title == "A fatal error has occured") {
        throw new Error('A fatal error has occured');
      }
      console.debug('generateProposal from new client', results['generateProposal from new client']);
      toastr.success('generateProposal from new client', results['generateProposal from new client']);
    } catch (error) {
      stopLoading();
      console.error('Error generating proposal from new client: ' + error.message);
      alert('Error generating proposal from new client: ' + error.message);
      return;
    }

    benchmarkNextFunction = true;
    start = performance.now();
    await acceptProposal();
    end = performance.now();
    if (globalInitiative.title == "A fatal error has occured") {
      error = new Error('A fatal error has occured');
      console.error('Error accepting proposal: ' + error.message);
      alert('Error accepting proposal: ' + error.message);
      return;
    }
    results['acceptProposal'] = end - start;
    toastr.success('acceptProposal', results['acceptProposal']);
    console.debug('acceptProposal', results['acceptProposal']);

    try {
      startLoading('Deleting Project Files');
      await deleteProjectFiles();
      stopLoading();
    } catch {
      stopLoading();
      console.error('Error deleting project files: ' + error.message);
      alert('Error deleting project files: ' + error.message);
      return;
    }

    benchmarkNextFunction = true;
    start = performance.now();
    await openChangelog();
    end = performance.now();
    results['openChangelog'] = end - start;
    toastr.success('openChangelog', results['openChangelog']);
    console.debug('openChangelog', results['openChangelog']);

    return results;
  }

  async function selectEmptyProject() {
    await googleScript(()=>{}, 'selectEmptyProject', [], throwError);
  }

  async function selectEmptyProposal() {
    await googleScript(()=>{}, 'selectEmptyProposal', [], throwError);
  }

  async function selectFullProject() {
    await googleScript(()=>{}, 'selectFullProject', [], throwError);
  }

  async function selectFullProposal() {
    await googleScript(()=>{}, 'selectFullProposal', [], throwError);
 }

  async function selectNoDocsProject() {
    await googleScript(()=>{}, 'selectNoDocsProject', [], throwError);
  }

  async function selectNoDocsProposal() {
    await googleScript(()=>{}, 'selectNoDocsProposal', [], throwError);
  }

  async function selectNewProjectFromExistingClient() {
    await googleScript(()=>{}, 'selectNewProjectFromExistingClient', [], throwError);
  }

  async function deleteProject() {
    await googleScript(()=>{}, 'deleteProject', [], throwError);
  }

  async function deleteClientFiles() {
    await googleScript(()=>{}, 'deleteClientFiles', [], throwError);
  }

  async function selectNewProposal() {
    await googleScript(()=>{}, 'selectNewProposal', [], throwError);
  }

  async function deleteProposalFiles() {
    await googleScript(()=>{}, 'deleteProposalFiles', [], throwError);
  }

  async function deleteProjectFiles() {
    await googleScript(()=>{}, 'deleteProjectFiles', [], throwError);
  }
</script>